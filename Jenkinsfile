pipeline {
    agent {
        label 'cypress-node'
    }

    triggers {
        cron('30 20 * * 0-5')
    }

    options {
        ansiColor('xterm')
        buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20'))
        disableConcurrentBuilds()
        skipDefaultCheckout()
    }

    environment {
        TEST_DIR = 'tests/api'
        ALLURE_PATH = 'tests/api/allure-results'
        WORKSPACE_DIR = "${env.WORKSPACE}"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Executar') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'jenkins_registry', url: 'https://registry.sme.prefeitura.sp.gov.br/repository/sme-registry/') {
                        withCredentials([file(credentialsId: "cypress_env_ptrf", variable: 'env')]){    
                            sh '''
                                touch tests/api/.env
                                cp "$env" "tests/api/.env"
                                docker pull registry.sme.prefeitura.sp.gov.br/devops/cypress-agent:14.5.2
                                docker run \
                                    --rm \
                                    -v "$WORKSPACE/tests/api:/app" \
                                    -w /app \
                                    registry.sme.prefeitura.sp.gov.br/devops/cypress-agent:14.5.2 \
                                    sh -c "npm install && npm install cypress@14.5.2 cypress-cloud@beta && \
                                            npm install @shelex/cypress-allure-plugin allure-mocha crypto-js@4.1.1 --save-dev && \
                                            rm -rf allure-results/ && \
                                            npx cypress-cloud run \
                                                --parallel \
                                                --browser chrome \
                                                --headed true \
                                                --record \
                                                --key somekey \
                                                --reporter mocha-allure-reporter \
                                                --ci-build-id PTRF-BACKEND_JENKINS-BUILD-${BUILD_NUMBER} && \
                                            chown 1001:1001 * -R
                                            chmod 777 * -R"
                            '''
                        }
                    }

                    echo "FIM DOS TESTES!"
                    def logText = currentBuild.rawBuild.getLog(20).join('\n')
                    def match = logText =~ /Recorded Run:\s*(https?:\/\/\S+)/
                    if (match) {
                        env.CYPRESS_RUN_URL = match[0][1]
                    }
                }
            }
        }

        stage('Generate Allure Report') {
            steps {
                script {
                    catchError(buildResult: 'SUCCESS', stageResult: 'SUCCESS') {
                        def hasResults = fileExists("${ALLURE_PATH}") && sh(script: "ls -A ${ALLURE_PATH} | wc -l", returnStdout: true).trim() != "0"

                        if (hasResults) {
                            echo "Gerando relatório Allure..."
                            sh """
                                export JAVA_HOME=\$(dirname \$(dirname \$(readlink -f \$(which java)))); \
                                export PATH=\$JAVA_HOME/bin:/usr/local/bin:\$PATH; \
                                allure generate ${ALLURE_PATH} --clean --output tests/api/allure-report; \
                                cd tests/api; \
                                zip -r allure-results-${BUILD_NUMBER}-\$(date +"%d-%m-%Y").zip allure-results
                            """
                        } else {
                            echo "⚠️ Diretório ${ALLURE_PATH} está ausente ou vazio. Pulando geração do relatório."
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                withDockerRegistry(credentialsId: 'jenkins_registry', url: 'https://registry.sme.prefeitura.sp.gov.br/repository/sme-registry/') {
                    sh '''
                        docker pull registry.sme.prefeitura.sp.gov.br/devops/cypress-agent:14.5.2
                        docker run \
                            --rm \
                            -v "$WORKSPACE:/app" \
                            -w /app \
                            registry.sme.prefeitura.sp.gov.br/devops/cypress-agent:14.5.2 \
                            sh -c "rm -rf package-lock.json node_modules/ || true && chown 1001:1001 * -R || true  && chmod 777 * -R || true"
                    '''
                }
                
                if (fileExists("${ALLURE_PATH}") && sh(script: "ls -A ${ALLURE_PATH} | wc -l", returnStdout: true).trim() != "0") {
                    allure includeProperties: false, jdk: '', results: [[path: "${ALLURE_PATH}"]]
                } else {
                    echo "⚠️ Resultados do Allure não encontrados ou vazios, plugin Allure não será acionado."
                }

                def zipExists = sh(script: "ls tests/api/allure-results-*.zip 2>/dev/null || true", returnStdout: true).trim()
                if (zipExists) {
                    archiveArtifacts artifacts: 'tests/api/allure-results-*.zip', fingerprint: true
                } else {
                    echo "⚠️ Nenhum .zip de Allure encontrado para arquivamento. Pulando archiveArtifacts."
                }

                cleanWs(
                    patterns: [[pattern: '**/allure-results-*.zip', type: 'EXCLUDE']]
                )
            }
        }

        success { sendTelegram("<b>SUCESSO! ✅</b>") }
        unstable { sendTelegram("<b>INSTÁVEL! ⚠️</b>") }
        failure { sendTelegram("<b>FALHA! ❌</b>\n") }
        aborted { sendTelegram("<b>CANCELADO! ✖️</b>\n") }
    }
}

def sendTelegram(message) {
    def messageTemplate = (
        "<b>Job Name:</b> <a href='${JOB_URL}'>${JOB_NAME}</a>\n\n" +
        "<b>Status:</b> ${message}\n" +
        "<b>Build Number:</b> ${BUILD_DISPLAY_NAME}\n" +
        "<b>Dashboard Link:</b> <a href='${env.CYPRESS_RUN_URL}'>Resultados no dashboard</a>\n" +
        "<b>Log:</b> <a href='${env.BUILD_URL}console'>Ver console output</a>"
    )
    
    def encodedMessage = URLEncoder.encode(messageTemplate, "UTF-8")

    withCredentials([string(credentialsId: 'telegramTokensigpae', variable: 'TOKEN'),
    string(credentialsId: 'telegramChatIdsigpae', variable: 'CHAT_ID')]) {
        response = httpRequest (consoleLogResponseBody: true,
            contentType: 'APPLICATION_JSON',
            httpMode: 'GET',
            url: 'https://api.telegram.org/bot'+"$TOKEN"+'/sendMessage?text='+encodedMessage+'&chat_id='+"$CHAT_ID"+'&parse_mode='+"HTML"+'&disable_web_page_preview=true',
            validResponseCodes: '200')
        return response
    }
}